import sysfrom os.path import isfile, isdir, join, abspath, splitext, basename, exists, dirname, relpathfrom os import makedirs, remove as removefilefrom subprocess import Popen, PIPE, STDOUTfrom threading import Threadfrom queue import Queue, Emptyfrom cloakx import Extensionfrom cloakx.CloakBase import CloakBasefrom cloakx.CloakHTML import CloakHTMLimport cssutilsimport refrom bs4 import BeautifulSoupfrom logging import CRITICAL as CRITICAL_LOG_LEVELfrom cloakx.utils import multi_openfrom urllib.parse import urlencode, quote_plusfrom time import sleepfrom shutil import rmtreeimport distutilsfrom distutils import dir_util# from slimit import ast# from slimit.parser import Parser# from slimit.visitors import nodevisitor# from esprima import parseScriptfrom pprint import PrettyPrinterfrom collections import defaultdictimport jsonimport pprintfrom shutil import copyfileimport hashlibHTML_TEMPLATE_HEAD = "<html><body>\n"HTML_TEMPLATE_TAIL = "</body></html>\n"CEX_HTML_DIR = "cex_html"TAJS_LOC = join("..", "tajs-all.jar")TEMP_DIR = join(dirname(__file__),"temp")pp = PrettyPrinter(indent=2)class CloakJS(CloakBase):    @staticmethod    def fn_filter(fn):        return fn.endswith('.js') and isfile(fn)    def __init__(self, extension):        super().__init__()        self.ext = extension  # type: Extension        self.variable_regex = re.compile(self.ident_pattern, re.IGNORECASE)        cssutils.log.setLevel(CRITICAL_LOG_LEVEL)        self._js_fns = []    def clean_up_js(self):        raise Exception("-- clean_up_js is deprecated")        print("Beautifying")        processlist = []        for bfile in self._js_fns:            cmd = ["js-beautify", "--replace", bfile]            proc = Popen(cmd, stdout=PIPE, stderr=STDOUT, close_fds=True, bufsize=1)            # print(cmd)            processlist.append(proc)        for proc in processlist:            proc.wait()            stdout, stderr = proc.communicate()            if proc.returncode != 0:                print("!!!! beautification failed???? ")                print(stdout)                print(stderr)                exit(1283)        print("Beautification completed...")        print("Converting to ES2015")        cmd = ['npx', 'babel-cli', '--plugins', 'transform-object-rest-spread', '--presets=es2015-without-strict', self.ext.get_path,               '--out-file', 'temp-babel.js']        print(cmd)        proc = Popen(cmd, stdout=PIPE, stderr=STDOUT, close_fds=True, bufsize=1)        stdout, stderr = proc.communicate()        if proc.returncode != 0:            print(stdout)            self.ext.write_to_results("b")        else:            distutils.dir_util.copy_tree(TEMP_DIR + "/", self.ext.get_path)        print("Conversion completed...")    def build_unified_html(self):        if exists(TEMP_DIR):            rmtree(TEMP_DIR)        makedirs(TEMP_DIR)        self._js_fns = self.ext.get_filtered_filenames(CloakJS.fn_filter)        self.clean_up_js()        script_tags = ""        for fn in self._js_fns:            good_fn = quote_plus(join("..", relpath(fn)))            print (good_fn)            script_tags = script_tags + "\t<script src='%s'></script>\n" % good_fn            # todo: replace with write out to file            # write new css out to file            # with open('style_new.css', 'wb') as f:            #     f.write(parser.cssText)        self.htmlfn = join(dirname(__file__), CEX_HTML_DIR, self.ext.getappid() + ".html")        self.datafn = join(dirname(__file__), CEX_HTML_DIR, self.ext.getappid() + ".data")        htmlout = HTML_TEMPLATE_HEAD + script_tags + HTML_TEMPLATE_TAIL        open(self.htmlfn, "w+").write(htmlout)    def easy_find(self, id_map):        found = False        # problem, we want all the times        varpattern = re.compile("(^[.]?[ ])")        h = "[0-9a-f]"        unicode = "\\\\{h}{1,6}(\\r\\n|[ \\t\\r\\n\\f])?".replace("{h}", h)        escape = "({unicode}|\\\\[^\\r\\n\\f0-9a-f])".replace("{unicode}", unicode)        nonascii = "[\\240-\\377]"        nmchar = "([_A-Za-z0-9-]|{nonascii}|{escape})".replace("{nonascii}", nonascii).replace("{escape}", escape)        nmstart = "([_A-Za-z]|{nonascii}|{escape})".replace("{nonascii}", nonascii).replace("{escape}", escape)        ident = "-?{nmstart}{nmchar}*".replace("{nmstart}", nmstart).replace("{nmchar}", nmchar)        varpattern = re.compile(ident)        def find_vals(file_to_parse, strs_to_find):            print ("strs_to_find" + str(strs_to_find))            # returns file_cnt {'foundvar': [col1, col2, etc] }            file_cnts = {}            # print("var " + node.identifier.value + " value to >> " + node.initializer.value + " <<")            for line_index, line in enumerate(file_to_parse, 1):                for match_obj in varpattern.finditer(line):                    # find all id values in file and check agaisnt strs_to_find, if found then append to list for var                    if match_obj.group() in strs_to_find:                        var_found = match_obj.group()                        if var_found in file_cnts:                            file_cnts[match_obj.group()].append(line_index)                        else:                            file_cnts[match_obj.group()] = [line_index]                        #print (str(line_index) + " " +  match_obj.group())            return file_cnts        all_cnts = {}        for fn in self._js_fns:            vars_found = find_vals(open(fn), id_map)            if vars_found:                all_cnts[fn] = vars_found        if all_cnts:            pp.pprint(all_cnts)            json.dump(all_cnts, open(self.datafn, "w+"))        return all_cnts        # if False:        #     try:        #         jsdata=""        #         tree = parseScript(jsdata)        #        #         #tree = parser.parse(jsdata)        #        #         for node in nodevisitor.visit(tree):        #        #             cnt = 0        #             if isinstance(node, ast.VarDecl):        #        #                 if node.initializer is not None and type(node.initializer) is ast.String:        #                     cnt = find_vals(node.identifier.value, id_map)        #                     if cnt > 0:        #                         all_cnts[node.identifier.value] += cnt        #                         found = True        #                         print ("var " + node.identifier.value + ' = ' + node.initializer.value + "   cnt=%d"%cnt )        #        #             if isinstance(node, ast.Assign):        #                 if type(node.right) is ast.String:        #                     cnt = find_vals(node.right.value, id_map)        #                     if cnt > 0:        #                         all_cnts[node.right.value] += cnt        #                         found = True        #                         print("var " + node.left.value + "  = " + node.right.value + "    " + " cnt=%d" % cnt)        #                     #node.right.value = match_replace(node.right.value, str_to_find, replace)        #        #             if type(node) is ast.String:        #                 cnt = find_vals(node.value, id_map)        #                 if cnt > 0:        #                     all_cnts[node.value] += cnt        #                     found = True        #                     print("var " + node.value + " = " + " <<" + "    cnt=%d" % cnt )        #        #             #print(str(type(node)) + " " + str(vars(node)))        #        #     except SyntaxError as ser:        #         print (ser)        #         exit(929)        #         #parse Failed        #        # return all_cnts        # # print (ex)        #print(tree.to_ecma())    def extract_js(self,data):        script_out = ""        data = unquote(data)        data = data.replace("<script", "</script><script")        data += "</script>"        soup = BeautifulSoup(data, 'html.parser')        for script in soup.find_all("script"):            hasSource = False            if script.has_attr("src") and script['src'] is not None:                hasSource = True            # print("SCRIPT!!!{}".format(script))            if script.text is not None and len(script.text) > 5:                script_out += script.text + "\n"                script_out = script_out.replace("!!empty!!", "")                if len(script_out) > 5 and hasSource:                    print(data)        if len(script_out.replace("\n", "").strip()) > 5:            return script_out        else:            return ""    def prepare_js(self):        #print("Beautifying")        cmd = ["js-beautify", "--replace", "temp.js"]        proc = Popen(cmd, stdout=PIPE, stderr=STDOUT, close_fds=True, bufsize=1)        # print(cmd)        stdout, stderr = proc.communicate()        if proc.returncode != 0:            print(stdout)            print(stderr)            return {"Error:": "Beautification FAILED", "output": repr(stdout), "err": repr(stderr)}        #print("Beautification completed...")        #print("Converting to ES2015")        cmd = ['./node_modules/.bin/babel', '--plugins', 'transform-object-rest-spread', '--presets=es2015-without-strict', "temp.js",               '--out-file', 'temp_converted.js']        #print(cmd)        try:            pass            proc = Popen(cmd, stdout=PIPE, stderr=STDOUT, close_fds=True, bufsize=1)            stdout, stderr = proc.communicate()            if proc.returncode != 0:                return {"Error:": "Babel failed to convert ", "output": repr(stdout)}            copyfile("temp_converted.js", "temp.js")            removefile("temp_converted.js")        except Exception as err:            return {"Error:": "Babel failed to convert ", "output": repr(stdout)}        #print("Conversion completed...")                return {"msg": "Preparation of JS completed successfully"}    def analyze_js(self, search_str, js_fn):        if exists("temp.js.json"):            removefile("temp.js.json")        TAJS_LOC = "../tajs-most.jar"        cmd = ["timeout", "450", "java", "-Xmx8128M", "-jar", TAJS_LOC, "temp.js",               "-ignore-if", "-analysis-limitations-warn-only", "-propagate-dead-flow",               "-dom", "-uneval", "-determinacy", "-no-polymorphic",               "-no-messages", "-quiet", "-memory-usage", "-console-model", "-timing",               "-ignore-unreachable", "-no-object-sensitivity", "-no-control-sensitivity",               "-searchFor", search_str, "-searchType", "ID",               "-unsound", "-ignore-missing-native-models"]        #print("Executing Cmd {}".format(cmd))        proc = Popen(cmd, stdout=PIPE, stderr=PIPE, bufsize=1)        parsed = ""        stdout, stderr = proc.communicate()        # print (stdout)        if proc.returncode != 0:            str_stdout = ""            rtn_msg = {}            if proc.returncode == 124:                error_msg = self.ext.getappid() + "|" + js_fn  + "|Timedout processing JS file"                rtn_msg = {"error": "Timeout", "error_fn": js_fn, "cmd_search_str": search_str}            else:                if len(stdout) > 200:                    str_stdout = repr(stdout[0:100]) + "..." + repr(stdout[-100:])                else:                    str_stdout = repr(stdout[0:100])                error_msg = self.ext.getappid() + "|" + js_fn  + "|OUT:" + "|ERR:" + repr(stderr)                rtn_msg = {"error": "TAJS processing error", "error_fn": js_fn, "cmd_search_str": search_str,                           "stdout": repr(str_stdout),                           "stderr": repr(stderr)}            open("data/errors", "a").write(error_msg)            print(str_stdout)            print(stderr)            return rtn_msg        else:            if exists("temp.js.json"):                with open("temp.js.json","r") as jf:                    tajs_results = json.load(jf)                tajs_results["cmd_search_str"] = search_str                return tajs_results            else:                print(stdout)                print(stderr)                return {"error": "No Results from TAJS", "stdout": repr(stdout[0:100] + "..." + stdout[-100:]),                        "stderr": repr(stderr),                        "cmd_search_str": search_str}            # exit(85)    def get_json(self, json_path):        results = {}        with open(json_path, "r") as jf:            results = json.load(jf)        return results    def cloak_dropped_inline_scripts(self, droplets, id_map):        search_str = ",".join(list(id_map.keys()))        #print("SEARCH_STR={}".format(search_str))        cloak_results = []        for source_data in droplets:            js = source_data["script"]            hashvalue = source_data["hash"]            print("\tProcessing Inline JS from Droplet {} with hash {}".format(len(js), hashvalue))            open("temp.js", "w").write(js)            prep_results=self.prepare_js()            #print(open("temp.js", "r").read())            # md5 = hashlib.md5()            # md5.update(js.encode("utf-8"))            # hashvalue = md5.hexdigest()            #print("hashvalue={}".format(hashvalue))            js_fn = "droplet_" + hashvalue            analysis_results = self.analyze_js(search_str, js_fn)            analysis_results["prepare_js"] = prep_results            analysis_results["filename"] = js_fn            if not exists("temp.js.json"):                cloak_results.append(analysis_results)                continue            js_str, edited_lines = self.do_replacements(js, id_map)            analysis_results["edited_lines"] = len(edited_lines)            analysis_results["new_js"] = js_str            analysis_results["old_js"] = js            if len(edited_lines) > 0:                analysis_results["hash"] = hashvalue            cloak_results.append(analysis_results)        return cloak_results    def cloak_dropped_wars(self, wars, id_map):        e = self.ext # type: Extension        search_str = ",".join(list(id_map.keys()))        cloak_results = []        for war_fn in wars:            src_js_fn = e.get_path + war_fn            print("\tProcessing {} of size {}".format(src_js_fn, len(src_js_fn)))            if open(src_js_fn).read().find("//Cloaked") > -1:                print("\tSkipping already cloaked js file {}".format(e.get_path + war_fn))                continue            copyfile(src_js_fn, "temp.js")            prep_results = self.prepare_js()            analysis_results = self.analyze_js(search_str, src_js_fn)            analysis_results["filename"] = src_js_fn            analysis_results["prepare_js"] = prep_results            if not exists("temp.js.json"):                cloak_results.append(analysis_results)                # self.ext.write_to_results(key_name, analysis_results, False)                continue            js = open("temp.js", "r").read()            js_str, edited_lines = self.do_replacements(js, id_map)            analysis_results["edited_lines"] = len(edited_lines)            # self.ext.write_to_results(key_name, analysis_results, False)            cloak_results.append(analysis_results)            if len(edited_lines) > 0:                jout = open("temp.js", "w")                jout.write("//Cloaked")                jout.write("//Edited line(s) {}\n".format(" ".join(str(x) for x in edited_lines)))                jout.write(js_str + "\n")                jout.close()            copyfile("temp.js", e.get_path + war_fn)        return cloak_results    def do_replacements(self, js_, id_map):        edited_lines = []        with open("temp.js.json", "r") as jf:            search_results = json.load(jf)        #print("\nSearch Res={}:".format(search_results))        js_lines = []        if "matches" in search_results:            js_lines = open("temp.js", "r").read().split("\n")            for sr_k, res in search_results["matches"].items():                #print("{} == {}".format(sr_k, res))                for ev in res:                    line_no = ev['lineNumber'] - 1                    if line_no < len(js_lines):                        the_line = js_lines[line_no]                        if sr_k[1:] in the_line:                            the_line = the_line.replace(sr_k[1:], id_map[sr_k])                            js_lines[line_no] = the_line                            edited_lines.append(line_no)                        else:                            with open("data/line_not_written.json","a") as jf:                                json.dump({"results":ev, "line": js_lines[line_no], "appid": self.ext.getappid()})        return "\n".join(js_lines), edited_linesclass NonBlockingStreamReader:    def __init__(self, stream):        '''        stream: the stream to read from.                Usually a process' stdout or stderr.        '''        self._s = stream        self._q = Queue()        self._finished = False        def _populateQueue(stream, queue):            '''            Collect lines from 'stream' and put them in 'quque'.            '''            while True:                try:                    char = stream.read(1)                    if char:                        queue.put(char)                    else:                        self._finished = True                        #raise UnexpectedEndOfStream                except ValueError as ve:                    print("error reading from stream")                    print(ve)                    self._finished = True                    pass        self._t = Thread(target = _populateQueue, args=(self._s, self._q))        self._t.daemon = True        self._t.start() #start collecting lines from the stream    @property    def is_finished(self):        return self._finished    def read(self, timeout = None):        try:            if self._finished:                return None            return self._q.get(block = timeout is not None, timeout=timeout)        except Empty:            return Noneclass UnexpectedEndOfStream(Exception):    pass